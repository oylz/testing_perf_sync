// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vctn.proto

#ifndef PROTOBUF_INCLUDED_vctn_2eproto
#define PROTOBUF_INCLUDED_vctn_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vctn_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_vctn_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_vctn_2eproto();
namespace vctn {
class keytable_value;
class keytable_valueDefaultTypeInternal;
extern keytable_valueDefaultTypeInternal _keytable_value_default_instance_;
class route_value;
class route_valueDefaultTypeInternal;
extern route_valueDefaultTypeInternal _route_value_default_instance_;
class route_value_col;
class route_value_colDefaultTypeInternal;
extern route_value_colDefaultTypeInternal _route_value_col_default_instance_;
class vct_pos;
class vct_posDefaultTypeInternal;
extern vct_posDefaultTypeInternal _vct_pos_default_instance_;
class vct_value;
class vct_valueDefaultTypeInternal;
extern vct_valueDefaultTypeInternal _vct_value_default_instance_;
class vct_value_n;
class vct_value_nDefaultTypeInternal;
extern vct_value_nDefaultTypeInternal _vct_value_n_default_instance_;
}  // namespace vctn
namespace google {
namespace protobuf {
template<> ::vctn::keytable_value* Arena::CreateMaybeMessage<::vctn::keytable_value>(Arena*);
template<> ::vctn::route_value* Arena::CreateMaybeMessage<::vctn::route_value>(Arena*);
template<> ::vctn::route_value_col* Arena::CreateMaybeMessage<::vctn::route_value_col>(Arena*);
template<> ::vctn::vct_pos* Arena::CreateMaybeMessage<::vctn::vct_pos>(Arena*);
template<> ::vctn::vct_value* Arena::CreateMaybeMessage<::vctn::vct_value>(Arena*);
template<> ::vctn::vct_value_n* Arena::CreateMaybeMessage<::vctn::vct_value_n>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vctn {

// ===================================================================

class vct_pos final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vctn.vct_pos) */ {
 public:
  vct_pos();
  virtual ~vct_pos();

  vct_pos(const vct_pos& from);

  inline vct_pos& operator=(const vct_pos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  vct_pos(vct_pos&& from) noexcept
    : vct_pos() {
    *this = ::std::move(from);
  }

  inline vct_pos& operator=(vct_pos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const vct_pos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const vct_pos* internal_default_instance() {
    return reinterpret_cast<const vct_pos*>(
               &_vct_pos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(vct_pos* other);
  friend void swap(vct_pos& a, vct_pos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline vct_pos* New() const final {
    return CreateMaybeMessage<vct_pos>(nullptr);
  }

  vct_pos* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<vct_pos>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const vct_pos& from);
  void MergeFrom(const vct_pos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vct_pos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 posm_ = 1;
  bool has_posm_() const;
  void clear_posm_();
  static const int kPosmFieldNumber = 1;
  ::google::protobuf::int64 posm_() const;
  void set_posm_(::google::protobuf::int64 value);

  // required int64 poss_ = 2;
  bool has_poss_() const;
  void clear_poss_();
  static const int kPossFieldNumber = 2;
  ::google::protobuf::int64 poss_() const;
  void set_poss_(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vctn.vct_pos)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 posm__;
  ::google::protobuf::int64 poss__;
  friend struct ::TableStruct_vctn_2eproto;
};
// -------------------------------------------------------------------

class vct_value_n final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vctn.vct_value_n) */ {
 public:
  vct_value_n();
  virtual ~vct_value_n();

  vct_value_n(const vct_value_n& from);

  inline vct_value_n& operator=(const vct_value_n& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  vct_value_n(vct_value_n&& from) noexcept
    : vct_value_n() {
    *this = ::std::move(from);
  }

  inline vct_value_n& operator=(vct_value_n&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const vct_value_n& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const vct_value_n* internal_default_instance() {
    return reinterpret_cast<const vct_value_n*>(
               &_vct_value_n_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(vct_value_n* other);
  friend void swap(vct_value_n& a, vct_value_n& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline vct_value_n* New() const final {
    return CreateMaybeMessage<vct_value_n>(nullptr);
  }

  vct_value_n* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<vct_value_n>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const vct_value_n& from);
  void MergeFrom(const vct_value_n& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vct_value_n* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vctn.vct_pos pos_ = 1;
  bool has_pos_() const;
  void clear_pos_();
  static const int kPosFieldNumber = 1;
  const ::vctn::vct_pos& pos_() const;
  ::vctn::vct_pos* release_pos_();
  ::vctn::vct_pos* mutable_pos_();
  void set_allocated_pos_(::vctn::vct_pos* pos_);

  // required int64 a_ = 2;
  bool has_a_() const;
  void clear_a_();
  static const int kAFieldNumber = 2;
  ::google::protobuf::int64 a_() const;
  void set_a_(::google::protobuf::int64 value);

  // required int64 b_ = 3;
  bool has_b_() const;
  void clear_b_();
  static const int kBFieldNumber = 3;
  ::google::protobuf::int64 b_() const;
  void set_b_(::google::protobuf::int64 value);

  // required bool commit_ = 5;
  bool has_commit_() const;
  void clear_commit_();
  static const int kCommitFieldNumber = 5;
  bool commit_() const;
  void set_commit_(bool value);

  // @@protoc_insertion_point(class_scope:vctn.vct_value_n)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::vctn::vct_pos* pos__;
  ::google::protobuf::int64 a__;
  ::google::protobuf::int64 b__;
  bool commit__;
  friend struct ::TableStruct_vctn_2eproto;
};
// -------------------------------------------------------------------

class vct_value final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vctn.vct_value) */ {
 public:
  vct_value();
  virtual ~vct_value();

  vct_value(const vct_value& from);

  inline vct_value& operator=(const vct_value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  vct_value(vct_value&& from) noexcept
    : vct_value() {
    *this = ::std::move(from);
  }

  inline vct_value& operator=(vct_value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const vct_value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const vct_value* internal_default_instance() {
    return reinterpret_cast<const vct_value*>(
               &_vct_value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(vct_value* other);
  friend void swap(vct_value& a, vct_value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline vct_value* New() const final {
    return CreateMaybeMessage<vct_value>(nullptr);
  }

  vct_value* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<vct_value>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const vct_value& from);
  void MergeFrom(const vct_value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vct_value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vctn.vct_value_n his_ = 3;
  int his__size() const;
  void clear_his_();
  static const int kHisFieldNumber = 3;
  ::vctn::vct_value_n* mutable_his_(int index);
  ::google::protobuf::RepeatedPtrField< ::vctn::vct_value_n >*
      mutable_his_();
  const ::vctn::vct_value_n& his_(int index) const;
  ::vctn::vct_value_n* add_his_();
  const ::google::protobuf::RepeatedPtrField< ::vctn::vct_value_n >&
      his_() const;

  // required string key_ = 1;
  bool has_key_() const;
  void clear_key_();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key_() const;
  void set_key_(const ::std::string& value);
  #if LANG_CXX11
  void set_key_(::std::string&& value);
  #endif
  void set_key_(const char* value);
  void set_key_(const char* value, size_t size);
  ::std::string* mutable_key_();
  ::std::string* release_key_();
  void set_allocated_key_(::std::string* key_);

  // required .vctn.vct_value_n main_ = 2;
  bool has_main_() const;
  void clear_main_();
  static const int kMainFieldNumber = 2;
  const ::vctn::vct_value_n& main_() const;
  ::vctn::vct_value_n* release_main_();
  ::vctn::vct_value_n* mutable_main_();
  void set_allocated_main_(::vctn::vct_value_n* main_);

  // required int64 commit_count_ = 4;
  bool has_commit_count_() const;
  void clear_commit_count_();
  static const int kCommitCountFieldNumber = 4;
  ::google::protobuf::int64 commit_count_() const;
  void set_commit_count_(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vctn.vct_value)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::vctn::vct_value_n > his__;
  ::google::protobuf::internal::ArenaStringPtr key__;
  ::vctn::vct_value_n* main__;
  ::google::protobuf::int64 commit_count__;
  friend struct ::TableStruct_vctn_2eproto;
};
// -------------------------------------------------------------------

class keytable_value final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vctn.keytable_value) */ {
 public:
  keytable_value();
  virtual ~keytable_value();

  keytable_value(const keytable_value& from);

  inline keytable_value& operator=(const keytable_value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  keytable_value(keytable_value&& from) noexcept
    : keytable_value() {
    *this = ::std::move(from);
  }

  inline keytable_value& operator=(keytable_value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const keytable_value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const keytable_value* internal_default_instance() {
    return reinterpret_cast<const keytable_value*>(
               &_keytable_value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(keytable_value* other);
  friend void swap(keytable_value& a, keytable_value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline keytable_value* New() const final {
    return CreateMaybeMessage<keytable_value>(nullptr);
  }

  keytable_value* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<keytable_value>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const keytable_value& from);
  void MergeFrom(const keytable_value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(keytable_value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string field_ = 1;
  bool has_field_() const;
  void clear_field_();
  static const int kFieldFieldNumber = 1;
  const ::std::string& field_() const;
  void set_field_(const ::std::string& value);
  #if LANG_CXX11
  void set_field_(::std::string&& value);
  #endif
  void set_field_(const char* value);
  void set_field_(const char* value, size_t size);
  ::std::string* mutable_field_();
  ::std::string* release_field_();
  void set_allocated_field_(::std::string* field_);

  // required string route_table_ = 2;
  bool has_route_table_() const;
  void clear_route_table_();
  static const int kRouteTableFieldNumber = 2;
  const ::std::string& route_table_() const;
  void set_route_table_(const ::std::string& value);
  #if LANG_CXX11
  void set_route_table_(::std::string&& value);
  #endif
  void set_route_table_(const char* value);
  void set_route_table_(const char* value, size_t size);
  ::std::string* mutable_route_table_();
  ::std::string* release_route_table_();
  void set_allocated_route_table_(::std::string* route_table_);

  // required string route_table_field_ = 3;
  bool has_route_table_field_() const;
  void clear_route_table_field_();
  static const int kRouteTableFieldFieldNumber = 3;
  const ::std::string& route_table_field_() const;
  void set_route_table_field_(const ::std::string& value);
  #if LANG_CXX11
  void set_route_table_field_(::std::string&& value);
  #endif
  void set_route_table_field_(const char* value);
  void set_route_table_field_(const char* value, size_t size);
  ::std::string* mutable_route_table_field_();
  ::std::string* release_route_table_field_();
  void set_allocated_route_table_field_(::std::string* route_table_field_);

  // @@protoc_insertion_point(class_scope:vctn.keytable_value)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr field__;
  ::google::protobuf::internal::ArenaStringPtr route_table__;
  ::google::protobuf::internal::ArenaStringPtr route_table_field__;
  friend struct ::TableStruct_vctn_2eproto;
};
// -------------------------------------------------------------------

class route_value_col final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vctn.route_value_col) */ {
 public:
  route_value_col();
  virtual ~route_value_col();

  route_value_col(const route_value_col& from);

  inline route_value_col& operator=(const route_value_col& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  route_value_col(route_value_col&& from) noexcept
    : route_value_col() {
    *this = ::std::move(from);
  }

  inline route_value_col& operator=(route_value_col&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const route_value_col& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const route_value_col* internal_default_instance() {
    return reinterpret_cast<const route_value_col*>(
               &_route_value_col_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(route_value_col* other);
  friend void swap(route_value_col& a, route_value_col& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline route_value_col* New() const final {
    return CreateMaybeMessage<route_value_col>(nullptr);
  }

  route_value_col* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<route_value_col>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const route_value_col& from);
  void MergeFrom(const route_value_col& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(route_value_col* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name_ = 1;
  bool has_name_() const;
  void clear_name_();
  static const int kNameFieldNumber = 1;
  const ::std::string& name_() const;
  void set_name_(const ::std::string& value);
  #if LANG_CXX11
  void set_name_(::std::string&& value);
  #endif
  void set_name_(const char* value);
  void set_name_(const char* value, size_t size);
  ::std::string* mutable_name_();
  ::std::string* release_name_();
  void set_allocated_name_(::std::string* name_);

  // required string value_ = 2;
  bool has_value_() const;
  void clear_value_();
  static const int kValueFieldNumber = 2;
  const ::std::string& value_() const;
  void set_value_(const ::std::string& value);
  #if LANG_CXX11
  void set_value_(::std::string&& value);
  #endif
  void set_value_(const char* value);
  void set_value_(const char* value, size_t size);
  ::std::string* mutable_value_();
  ::std::string* release_value_();
  void set_allocated_value_(::std::string* value_);

  // @@protoc_insertion_point(class_scope:vctn.route_value_col)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name__;
  ::google::protobuf::internal::ArenaStringPtr value__;
  friend struct ::TableStruct_vctn_2eproto;
};
// -------------------------------------------------------------------

class route_value final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vctn.route_value) */ {
 public:
  route_value();
  virtual ~route_value();

  route_value(const route_value& from);

  inline route_value& operator=(const route_value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  route_value(route_value&& from) noexcept
    : route_value() {
    *this = ::std::move(from);
  }

  inline route_value& operator=(route_value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const route_value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const route_value* internal_default_instance() {
    return reinterpret_cast<const route_value*>(
               &_route_value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(route_value* other);
  friend void swap(route_value& a, route_value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline route_value* New() const final {
    return CreateMaybeMessage<route_value>(nullptr);
  }

  route_value* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<route_value>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const route_value& from);
  void MergeFrom(const route_value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(route_value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vctn.route_value_col col_ = 3;
  int col__size() const;
  void clear_col_();
  static const int kColFieldNumber = 3;
  ::vctn::route_value_col* mutable_col_(int index);
  ::google::protobuf::RepeatedPtrField< ::vctn::route_value_col >*
      mutable_col_();
  const ::vctn::route_value_col& col_(int index) const;
  ::vctn::route_value_col* add_col_();
  const ::google::protobuf::RepeatedPtrField< ::vctn::route_value_col >&
      col_() const;

  // required string region_ = 1;
  bool has_region_() const;
  void clear_region_();
  static const int kRegionFieldNumber = 1;
  const ::std::string& region_() const;
  void set_region_(const ::std::string& value);
  #if LANG_CXX11
  void set_region_(::std::string&& value);
  #endif
  void set_region_(const char* value);
  void set_region_(const char* value, size_t size);
  ::std::string* mutable_region_();
  ::std::string* release_region_();
  void set_allocated_region_(::std::string* region_);

  // required string area_ = 2;
  bool has_area_() const;
  void clear_area_();
  static const int kAreaFieldNumber = 2;
  const ::std::string& area_() const;
  void set_area_(const ::std::string& value);
  #if LANG_CXX11
  void set_area_(::std::string&& value);
  #endif
  void set_area_(const char* value);
  void set_area_(const char* value, size_t size);
  ::std::string* mutable_area_();
  ::std::string* release_area_();
  void set_allocated_area_(::std::string* area_);

  // @@protoc_insertion_point(class_scope:vctn.route_value)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::vctn::route_value_col > col__;
  ::google::protobuf::internal::ArenaStringPtr region__;
  ::google::protobuf::internal::ArenaStringPtr area__;
  friend struct ::TableStruct_vctn_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// vct_pos

// required int64 posm_ = 1;
inline bool vct_pos::has_posm_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vct_pos::clear_posm_() {
  posm__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int64 vct_pos::posm_() const {
  // @@protoc_insertion_point(field_get:vctn.vct_pos.posm_)
  return posm__;
}
inline void vct_pos::set_posm_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  posm__ = value;
  // @@protoc_insertion_point(field_set:vctn.vct_pos.posm_)
}

// required int64 poss_ = 2;
inline bool vct_pos::has_poss_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vct_pos::clear_poss_() {
  poss__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int64 vct_pos::poss_() const {
  // @@protoc_insertion_point(field_get:vctn.vct_pos.poss_)
  return poss__;
}
inline void vct_pos::set_poss_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  poss__ = value;
  // @@protoc_insertion_point(field_set:vctn.vct_pos.poss_)
}

// -------------------------------------------------------------------

// vct_value_n

// required .vctn.vct_pos pos_ = 1;
inline bool vct_value_n::has_pos_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vct_value_n::clear_pos_() {
  if (pos__ != nullptr) pos__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::vctn::vct_pos& vct_value_n::pos_() const {
  const ::vctn::vct_pos* p = pos__;
  // @@protoc_insertion_point(field_get:vctn.vct_value_n.pos_)
  return p != nullptr ? *p : *reinterpret_cast<const ::vctn::vct_pos*>(
      &::vctn::_vct_pos_default_instance_);
}
inline ::vctn::vct_pos* vct_value_n::release_pos_() {
  // @@protoc_insertion_point(field_release:vctn.vct_value_n.pos_)
  _has_bits_[0] &= ~0x00000001u;
  ::vctn::vct_pos* temp = pos__;
  pos__ = nullptr;
  return temp;
}
inline ::vctn::vct_pos* vct_value_n::mutable_pos_() {
  _has_bits_[0] |= 0x00000001u;
  if (pos__ == nullptr) {
    auto* p = CreateMaybeMessage<::vctn::vct_pos>(GetArenaNoVirtual());
    pos__ = p;
  }
  // @@protoc_insertion_point(field_mutable:vctn.vct_value_n.pos_)
  return pos__;
}
inline void vct_value_n::set_allocated_pos_(::vctn::vct_pos* pos_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pos__;
  }
  if (pos_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pos__ = pos_;
  // @@protoc_insertion_point(field_set_allocated:vctn.vct_value_n.pos_)
}

// required int64 a_ = 2;
inline bool vct_value_n::has_a_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vct_value_n::clear_a_() {
  a__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int64 vct_value_n::a_() const {
  // @@protoc_insertion_point(field_get:vctn.vct_value_n.a_)
  return a__;
}
inline void vct_value_n::set_a_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  a__ = value;
  // @@protoc_insertion_point(field_set:vctn.vct_value_n.a_)
}

// required int64 b_ = 3;
inline bool vct_value_n::has_b_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void vct_value_n::clear_b_() {
  b__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int64 vct_value_n::b_() const {
  // @@protoc_insertion_point(field_get:vctn.vct_value_n.b_)
  return b__;
}
inline void vct_value_n::set_b_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  b__ = value;
  // @@protoc_insertion_point(field_set:vctn.vct_value_n.b_)
}

// required bool commit_ = 5;
inline bool vct_value_n::has_commit_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void vct_value_n::clear_commit_() {
  commit__ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool vct_value_n::commit_() const {
  // @@protoc_insertion_point(field_get:vctn.vct_value_n.commit_)
  return commit__;
}
inline void vct_value_n::set_commit_(bool value) {
  _has_bits_[0] |= 0x00000008u;
  commit__ = value;
  // @@protoc_insertion_point(field_set:vctn.vct_value_n.commit_)
}

// -------------------------------------------------------------------

// vct_value

// required string key_ = 1;
inline bool vct_value::has_key_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vct_value::clear_key_() {
  key__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& vct_value::key_() const {
  // @@protoc_insertion_point(field_get:vctn.vct_value.key_)
  return key__.GetNoArena();
}
inline void vct_value::set_key_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.vct_value.key_)
}
#if LANG_CXX11
inline void vct_value::set_key_(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.vct_value.key_)
}
#endif
inline void vct_value::set_key_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.vct_value.key_)
}
inline void vct_value::set_key_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.vct_value.key_)
}
inline ::std::string* vct_value::mutable_key_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:vctn.vct_value.key_)
  return key__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* vct_value::release_key_() {
  // @@protoc_insertion_point(field_release:vctn.vct_value.key_)
  if (!has_key_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void vct_value::set_allocated_key_(::std::string* key_) {
  if (key_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_);
  // @@protoc_insertion_point(field_set_allocated:vctn.vct_value.key_)
}

// required .vctn.vct_value_n main_ = 2;
inline bool vct_value::has_main_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vct_value::clear_main_() {
  if (main__ != nullptr) main__->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::vctn::vct_value_n& vct_value::main_() const {
  const ::vctn::vct_value_n* p = main__;
  // @@protoc_insertion_point(field_get:vctn.vct_value.main_)
  return p != nullptr ? *p : *reinterpret_cast<const ::vctn::vct_value_n*>(
      &::vctn::_vct_value_n_default_instance_);
}
inline ::vctn::vct_value_n* vct_value::release_main_() {
  // @@protoc_insertion_point(field_release:vctn.vct_value.main_)
  _has_bits_[0] &= ~0x00000002u;
  ::vctn::vct_value_n* temp = main__;
  main__ = nullptr;
  return temp;
}
inline ::vctn::vct_value_n* vct_value::mutable_main_() {
  _has_bits_[0] |= 0x00000002u;
  if (main__ == nullptr) {
    auto* p = CreateMaybeMessage<::vctn::vct_value_n>(GetArenaNoVirtual());
    main__ = p;
  }
  // @@protoc_insertion_point(field_mutable:vctn.vct_value.main_)
  return main__;
}
inline void vct_value::set_allocated_main_(::vctn::vct_value_n* main_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete main__;
  }
  if (main_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      main_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, main_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  main__ = main_;
  // @@protoc_insertion_point(field_set_allocated:vctn.vct_value.main_)
}

// repeated .vctn.vct_value_n his_ = 3;
inline int vct_value::his__size() const {
  return his__.size();
}
inline void vct_value::clear_his_() {
  his__.Clear();
}
inline ::vctn::vct_value_n* vct_value::mutable_his_(int index) {
  // @@protoc_insertion_point(field_mutable:vctn.vct_value.his_)
  return his__.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vctn::vct_value_n >*
vct_value::mutable_his_() {
  // @@protoc_insertion_point(field_mutable_list:vctn.vct_value.his_)
  return &his__;
}
inline const ::vctn::vct_value_n& vct_value::his_(int index) const {
  // @@protoc_insertion_point(field_get:vctn.vct_value.his_)
  return his__.Get(index);
}
inline ::vctn::vct_value_n* vct_value::add_his_() {
  // @@protoc_insertion_point(field_add:vctn.vct_value.his_)
  return his__.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vctn::vct_value_n >&
vct_value::his_() const {
  // @@protoc_insertion_point(field_list:vctn.vct_value.his_)
  return his__;
}

// required int64 commit_count_ = 4;
inline bool vct_value::has_commit_count_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void vct_value::clear_commit_count_() {
  commit_count__ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int64 vct_value::commit_count_() const {
  // @@protoc_insertion_point(field_get:vctn.vct_value.commit_count_)
  return commit_count__;
}
inline void vct_value::set_commit_count_(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  commit_count__ = value;
  // @@protoc_insertion_point(field_set:vctn.vct_value.commit_count_)
}

// -------------------------------------------------------------------

// keytable_value

// required string field_ = 1;
inline bool keytable_value::has_field_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void keytable_value::clear_field_() {
  field__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& keytable_value::field_() const {
  // @@protoc_insertion_point(field_get:vctn.keytable_value.field_)
  return field__.GetNoArena();
}
inline void keytable_value::set_field_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  field__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.keytable_value.field_)
}
#if LANG_CXX11
inline void keytable_value::set_field_(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  field__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.keytable_value.field_)
}
#endif
inline void keytable_value::set_field_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  field__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.keytable_value.field_)
}
inline void keytable_value::set_field_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  field__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.keytable_value.field_)
}
inline ::std::string* keytable_value::mutable_field_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:vctn.keytable_value.field_)
  return field__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* keytable_value::release_field_() {
  // @@protoc_insertion_point(field_release:vctn.keytable_value.field_)
  if (!has_field_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return field__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void keytable_value::set_allocated_field_(::std::string* field_) {
  if (field_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_);
  // @@protoc_insertion_point(field_set_allocated:vctn.keytable_value.field_)
}

// required string route_table_ = 2;
inline bool keytable_value::has_route_table_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void keytable_value::clear_route_table_() {
  route_table__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& keytable_value::route_table_() const {
  // @@protoc_insertion_point(field_get:vctn.keytable_value.route_table_)
  return route_table__.GetNoArena();
}
inline void keytable_value::set_route_table_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  route_table__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.keytable_value.route_table_)
}
#if LANG_CXX11
inline void keytable_value::set_route_table_(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  route_table__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.keytable_value.route_table_)
}
#endif
inline void keytable_value::set_route_table_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  route_table__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.keytable_value.route_table_)
}
inline void keytable_value::set_route_table_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  route_table__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.keytable_value.route_table_)
}
inline ::std::string* keytable_value::mutable_route_table_() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:vctn.keytable_value.route_table_)
  return route_table__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* keytable_value::release_route_table_() {
  // @@protoc_insertion_point(field_release:vctn.keytable_value.route_table_)
  if (!has_route_table_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return route_table__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void keytable_value::set_allocated_route_table_(::std::string* route_table_) {
  if (route_table_ != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  route_table__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), route_table_);
  // @@protoc_insertion_point(field_set_allocated:vctn.keytable_value.route_table_)
}

// required string route_table_field_ = 3;
inline bool keytable_value::has_route_table_field_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void keytable_value::clear_route_table_field_() {
  route_table_field__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& keytable_value::route_table_field_() const {
  // @@protoc_insertion_point(field_get:vctn.keytable_value.route_table_field_)
  return route_table_field__.GetNoArena();
}
inline void keytable_value::set_route_table_field_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  route_table_field__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.keytable_value.route_table_field_)
}
#if LANG_CXX11
inline void keytable_value::set_route_table_field_(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  route_table_field__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.keytable_value.route_table_field_)
}
#endif
inline void keytable_value::set_route_table_field_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  route_table_field__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.keytable_value.route_table_field_)
}
inline void keytable_value::set_route_table_field_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  route_table_field__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.keytable_value.route_table_field_)
}
inline ::std::string* keytable_value::mutable_route_table_field_() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:vctn.keytable_value.route_table_field_)
  return route_table_field__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* keytable_value::release_route_table_field_() {
  // @@protoc_insertion_point(field_release:vctn.keytable_value.route_table_field_)
  if (!has_route_table_field_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return route_table_field__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void keytable_value::set_allocated_route_table_field_(::std::string* route_table_field_) {
  if (route_table_field_ != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  route_table_field__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), route_table_field_);
  // @@protoc_insertion_point(field_set_allocated:vctn.keytable_value.route_table_field_)
}

// -------------------------------------------------------------------

// route_value_col

// required string name_ = 1;
inline bool route_value_col::has_name_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void route_value_col::clear_name_() {
  name__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& route_value_col::name_() const {
  // @@protoc_insertion_point(field_get:vctn.route_value_col.name_)
  return name__.GetNoArena();
}
inline void route_value_col::set_name_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.route_value_col.name_)
}
#if LANG_CXX11
inline void route_value_col::set_name_(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.route_value_col.name_)
}
#endif
inline void route_value_col::set_name_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.route_value_col.name_)
}
inline void route_value_col::set_name_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.route_value_col.name_)
}
inline ::std::string* route_value_col::mutable_name_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:vctn.route_value_col.name_)
  return name__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* route_value_col::release_name_() {
  // @@protoc_insertion_point(field_release:vctn.route_value_col.name_)
  if (!has_name_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void route_value_col::set_allocated_name_(::std::string* name_) {
  if (name_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name_);
  // @@protoc_insertion_point(field_set_allocated:vctn.route_value_col.name_)
}

// required string value_ = 2;
inline bool route_value_col::has_value_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void route_value_col::clear_value_() {
  value__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& route_value_col::value_() const {
  // @@protoc_insertion_point(field_get:vctn.route_value_col.value_)
  return value__.GetNoArena();
}
inline void route_value_col::set_value_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.route_value_col.value_)
}
#if LANG_CXX11
inline void route_value_col::set_value_(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.route_value_col.value_)
}
#endif
inline void route_value_col::set_value_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.route_value_col.value_)
}
inline void route_value_col::set_value_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.route_value_col.value_)
}
inline ::std::string* route_value_col::mutable_value_() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:vctn.route_value_col.value_)
  return value__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* route_value_col::release_value_() {
  // @@protoc_insertion_point(field_release:vctn.route_value_col.value_)
  if (!has_value_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void route_value_col::set_allocated_value_(::std::string* value_) {
  if (value_ != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value_);
  // @@protoc_insertion_point(field_set_allocated:vctn.route_value_col.value_)
}

// -------------------------------------------------------------------

// route_value

// required string region_ = 1;
inline bool route_value::has_region_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void route_value::clear_region_() {
  region__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& route_value::region_() const {
  // @@protoc_insertion_point(field_get:vctn.route_value.region_)
  return region__.GetNoArena();
}
inline void route_value::set_region_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  region__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.route_value.region_)
}
#if LANG_CXX11
inline void route_value::set_region_(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  region__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.route_value.region_)
}
#endif
inline void route_value::set_region_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  region__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.route_value.region_)
}
inline void route_value::set_region_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  region__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.route_value.region_)
}
inline ::std::string* route_value::mutable_region_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:vctn.route_value.region_)
  return region__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* route_value::release_region_() {
  // @@protoc_insertion_point(field_release:vctn.route_value.region_)
  if (!has_region_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return region__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void route_value::set_allocated_region_(::std::string* region_) {
  if (region_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region_);
  // @@protoc_insertion_point(field_set_allocated:vctn.route_value.region_)
}

// required string area_ = 2;
inline bool route_value::has_area_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void route_value::clear_area_() {
  area__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& route_value::area_() const {
  // @@protoc_insertion_point(field_get:vctn.route_value.area_)
  return area__.GetNoArena();
}
inline void route_value::set_area_(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  area__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vctn.route_value.area_)
}
#if LANG_CXX11
inline void route_value::set_area_(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  area__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vctn.route_value.area_)
}
#endif
inline void route_value::set_area_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  area__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vctn.route_value.area_)
}
inline void route_value::set_area_(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  area__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vctn.route_value.area_)
}
inline ::std::string* route_value::mutable_area_() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:vctn.route_value.area_)
  return area__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* route_value::release_area_() {
  // @@protoc_insertion_point(field_release:vctn.route_value.area_)
  if (!has_area_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return area__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void route_value::set_allocated_area_(::std::string* area_) {
  if (area_ != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  area__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), area_);
  // @@protoc_insertion_point(field_set_allocated:vctn.route_value.area_)
}

// repeated .vctn.route_value_col col_ = 3;
inline int route_value::col__size() const {
  return col__.size();
}
inline void route_value::clear_col_() {
  col__.Clear();
}
inline ::vctn::route_value_col* route_value::mutable_col_(int index) {
  // @@protoc_insertion_point(field_mutable:vctn.route_value.col_)
  return col__.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vctn::route_value_col >*
route_value::mutable_col_() {
  // @@protoc_insertion_point(field_mutable_list:vctn.route_value.col_)
  return &col__;
}
inline const ::vctn::route_value_col& route_value::col_(int index) const {
  // @@protoc_insertion_point(field_get:vctn.route_value.col_)
  return col__.Get(index);
}
inline ::vctn::route_value_col* route_value::add_col_() {
  // @@protoc_insertion_point(field_add:vctn.route_value.col_)
  return col__.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vctn::route_value_col >&
route_value::col_() const {
  // @@protoc_insertion_point(field_list:vctn.route_value.col_)
  return col__;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vctn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_vctn_2eproto
